import { Task } from '../../../shared/types/task';
import { AppSettings, StorageAdapter, StorageType } from '../../../shared/types/settings';

export class FileSystemAdapter implements StorageAdapter {
  public readonly type: StorageType = 'fileSystem';
  private dataPath: string;
  private tasksFile: string;
  private settingsFile: string;
  private backupsDir: string;

  constructor(dataPath?: string) {
    if (!window.electronAPI) {
      throw new Error('FileSystemAdapter requires Electron API access');
    }

    // Default data path: user home directory + .krigzis
    this.dataPath = dataPath || window.electronAPI.path.join(
      window.electronAPI.os.homedir(),
      '.krigzis'
    );
    
    this.tasksFile = window.electronAPI.path.join(this.dataPath, 'tasks.json');
    this.settingsFile = window.electronAPI.path.join(this.dataPath, 'settings.json');
    this.backupsDir = window.electronAPI.path.join(this.dataPath, 'backups');
  }

  async isAvailable(): Promise<boolean> {
    try {
      return !!window.electronAPI?.fs;
    } catch {
      return false;
    }
  }

  async init(): Promise<void> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      // Create data directory if it doesn't exist
      if (!(await window.electronAPI.fs.exists(this.dataPath))) {
        await window.electronAPI.fs.mkdir(this.dataPath);
      }

      // Create backups directory if it doesn't exist
      if (!(await window.electronAPI.fs.exists(this.backupsDir))) {
        await window.electronAPI.fs.mkdir(this.backupsDir);
      }
    } catch (error) {
      console.error('Error initializing FileSystemAdapter:', error);
      throw new Error('Failed to initialize file system storage');
    }
  }

  async destroy(): Promise<void> {
    // No cleanup needed for file system adapter
    return Promise.resolve();
  }

  async getTasks(): Promise<Task[]> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      if (!(await window.electronAPI.fs.exists(this.tasksFile))) {
        return [];
      }

      const tasksJson = await window.electronAPI.fs.readFile(this.tasksFile);
      const tasks = JSON.parse(tasksJson);
      return Array.isArray(tasks) ? tasks : [];
    } catch (error) {
      console.error('Error loading tasks from file:', error);
      return [];
    }
  }

  async saveTasks(tasks: Task[]): Promise<void> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      const tasksJson = JSON.stringify(tasks, null, 2);
      await window.electronAPI.fs.writeFile(this.tasksFile, tasksJson);
    } catch (error) {
      console.error('Error saving tasks to file:', error);
      throw new Error('Failed to save tasks to file system');
    }
  }

  async getSettings(): Promise<AppSettings | null> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      if (!(await window.electronAPI.fs.exists(this.settingsFile))) {
        return null;
      }

      const settingsJson = await window.electronAPI.fs.readFile(this.settingsFile);
      return JSON.parse(settingsJson);
    } catch (error) {
      console.error('Error loading settings from file:', error);
      return null;
    }
  }

  async saveSettings(settings: AppSettings): Promise<void> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      const settingsJson = JSON.stringify(settings, null, 2);
      await window.electronAPI.fs.writeFile(this.settingsFile, settingsJson);
    } catch (error) {
      console.error('Error saving settings to file:', error);
      throw new Error('Failed to save settings to file system');
    }
  }

  async createBackup(): Promise<string> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      const timestamp = new Date().toISOString().replace(/[:]/g, '-');
      const backupFileName = `backup-${timestamp}.json`;
      const backupFilePath = window.electronAPI.path.join(this.backupsDir, backupFileName);
      
      const tasks = await this.getTasks();
      const settings = await this.getSettings();
      
      const backupData = {
        timestamp,
        tasks,
        settings,
        version: '1.0.0'
      };
      
      const backupJson = JSON.stringify(backupData, null, 2);
      await window.electronAPI.fs.writeFile(backupFilePath, backupJson);
      
      return backupFilePath;
    } catch (error) {
      console.error('Error creating backup:', error);
      throw new Error('Failed to create backup');
    }
  }

  async restoreBackup(backupPath: string): Promise<void> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      if (!(await window.electronAPI.fs.exists(backupPath))) {
        throw new Error('Backup file not found');
      }
      
      const backupJson = await window.electronAPI.fs.readFile(backupPath);
      const backupData = JSON.parse(backupJson);
      
      if (backupData.tasks) {
        await this.saveTasks(backupData.tasks);
      }
      
      if (backupData.settings) {
        await this.saveSettings(backupData.settings);
      }
    } catch (error) {
      console.error('Error restoring backup:', error);
      throw new Error('Failed to restore backup');
    }
  }

  async listBackups(): Promise<string[]> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      if (!(await window.electronAPI.fs.exists(this.backupsDir))) {
        return [];
      }

      const files = await window.electronAPI.fs.readdir(this.backupsDir);
      const backupFiles = files
        .filter(file => file.startsWith('backup-') && file.endsWith('.json'))
        .map(file => window.electronAPI!.path.join(this.backupsDir, file))
        .sort()
        .reverse(); // Newest first

      return backupFiles;
    } catch (error) {
      console.error('Error listing backups:', error);
      return [];
    }
  }

  async deleteBackup(backupPath: string): Promise<void> {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }

    try {
      if (await window.electronAPI.fs.exists(backupPath)) {
        await window.electronAPI.fs.unlink(backupPath);
      }
    } catch (error) {
      console.error('Error deleting backup:', error);
      throw new Error('Failed to delete backup');
    }
  }

  // Get data path for display purposes
  getDataPath(): string {
    return this.dataPath;
  }
} 